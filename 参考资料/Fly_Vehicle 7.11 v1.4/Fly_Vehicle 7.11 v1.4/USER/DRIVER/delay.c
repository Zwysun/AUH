#include "delay.h"

////////////////////////////////////////////////////////////////////////////////// 	 
//如果需要使用OS,则包括下面的头文件即可.
#if SYSTEM_SUPPORT_OS
#include "FreeRTOS.h"					//FreeRTOS使用		  
#include "task.h" 
#endif
//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32开发板
//使用SysTick的普通计数模式对延迟进行管理(支持OS)
//包括delay_us,delay_ms
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2016/11/28
//版本：V1.8
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
//All rights reserved
//********************************************************************************
//修改说明
//////////////////////////////////////////////////////////////////////////////////  

static u8  fac_us=0;							//us延时倍乘数			   
static u16 fac_ms=0;							//ms延时倍乘数,在ucos下,代表每个节拍的ms数
 
 
extern void xPortSysTickHandler(void);

//systick中断服务函数,使用ucos时用到
//void SysTick_Handler(void)
//{	
//    if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
//    {
//        xPortSysTickHandler();	
//    }
//}
//初始化延迟函数
//SYSTICK的时钟固定为AHB时钟，基础例程里面SYSTICK时钟频率为AHB/8
//这里为了兼容FreeRTOS，所以将SYSTICK的时钟频率改为AHB的频率！
//SYSCLK:系统时钟频率
void delay_init()
{
	u32 reload;
	
	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//选择外部时钟  HCLK
	fac_us=SystemCoreClock/1000000;				      //不论是否使用OS,fac_us都需要使用
	reload=SystemCoreClock/1000000;				      //每秒钟的计数次数 单位为M  
	reload*=1000000/configTICK_RATE_HZ;			    //根据configTICK_RATE_HZ设定溢出时间
						           //reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右	
	fac_ms=1000/configTICK_RATE_HZ;		          //代表OS可以延时的最少单位	   

	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
	SysTick->LOAD=reload; 											//每1/configTICK_RATE_HZ秒中断一次	
	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
}			   
void delay_sys_us(uint16_t us)
{
   
	 for(u16 time = 0;time<us*72;time++)
		{
			__NOP;
		}
}							    
//void delay_sys_us(uint16_t us)
//{
//    uint16_t differ=0xffff-us-5;
//    /*为防止因中断打断延时，造成计数错误.
//     如从0xfffE开始延时1us,但由于中断打断
//    （此时计数器仍在计数），本因计数至0xffff）
//    便停止计数，但由于错过计数值，并重载arr值，
//    导致实际延时(0xffff+1)us
//    */

//    HAL_TIM_Base_Start(&htim6);

//    __HAL_TIM_SET_COUNTER(&htim6,differ);

//    while(differ<0xffff-5)
//    {
//        differ=__HAL_TIM_GET_COUNTER(&htim6);
//    }

//    HAL_TIM_Base_Stop(&htim6);
//}

//延时nus
//nus:要延时的us数.	
//nus:0~204522252(最大值即2^32/fac_us@fac_us=168)	    								   
//void delay_sys_us(u16 nus)
//{		
//	u32 ticks;
//	u32 told,tnow,tcnt=0;
//	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
//	ticks=nus*fac_us; 						  //需要的节拍数 
//	told=SysTick->VAL;        		  //刚进入时的计数器值
//	while(1)
//	{
//		tnow=SysTick->VAL;	
//		if(tnow!=told)
//		{	    
//			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
//			else tcnt+=reload-tnow+told;	    
//			told=tnow;
//			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
//		}  
//	};	
//	
// 	
//}  
